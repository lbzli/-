# 图解算法

## 二分查找
我随便想一个1~100的数字。
你的目标是以最少的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了
- 查找方式
	+ 方式一：假设你从1开始依次往上猜，猜测过程会就是简单査找，更准确的说法是傻找。每次猜测都只能排除一个数字。如果我想的数字是99，你得猜99次才能猜到
	+ 方式二：一种更佳的猜法。从50开始。
		* 小了，但排除了一半的数字！至此，你知道1~50都小了。接下来，你猜75。
		* 大了，那余下的数字又排除了一半！使用二分査找时，你猜测的是中间的数字，从而每次都将余下的数字排除一半，你猜63（50和75中间的数字）
		* 这就是二分查找，你学习了第一种算法！
		

## 选择排序

|      | 数组 | 链表 |
| ---- | ---- | ---- |
| 读取 | O(1) | O(n) |
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1) |

[^这是数组和链表的O表示]:

假设你的计算机存储了很多乐曲。对于每个乐队，你都记录了其作品被播放的次数
你要将这个列表按播放次数从多到少的顺序排列，从而将你喜欢的乐队排序。该如何做呢？
- 一种办法是遍历这个列表，找出作品播放次数最多的乐队，并将该乐队添加到一个新列表中。
- 再次这样做，找出播放次数第二多的乐队。
- 继续这样做，你将得到一个有序列表
这就是选择排序
选择排序是一种灵巧的算法，但其速度不是很快。快速排序是一种更快的排序算法，其运行时间为O（n1ogn）

## 递归
函数的自我调用
编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分：**基线条件（base case）**和**递归条件（recursive case）**。*递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己*，从而避免形成无限循环

```python
def countdown (i) :
	print i
  if i <= 1 :--------基线条件
	return
  else :	 --------递归条件
	dountdown (i-1)
```

